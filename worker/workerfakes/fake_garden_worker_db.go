// This file was generated by counterfeiter
package workerfakes

import (
	"sync"

	"code.cloudfoundry.org/lager"
	"github.com/concourse/atc/db"
	"github.com/concourse/atc/db/lock"
	"github.com/concourse/atc/worker"
)

type FakeGardenWorkerDB struct {
	GetPipelineByIDStub        func(pipelineID int) (db.SavedPipeline, error)
	getPipelineByIDMutex       sync.RWMutex
	getPipelineByIDArgsForCall []struct {
		pipelineID int
	}
	getPipelineByIDReturns struct {
		result1 db.SavedPipeline
		result2 error
	}
	getPipelineByIDReturnsOnCall map[int]struct {
		result1 db.SavedPipeline
		result2 error
	}
	AcquireVolumeCreatingLockStub        func(lager.Logger, int) (lock.Lock, bool, error)
	acquireVolumeCreatingLockMutex       sync.RWMutex
	acquireVolumeCreatingLockArgsForCall []struct {
		arg1 lager.Logger
		arg2 int
	}
	acquireVolumeCreatingLockReturns struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}
	acquireVolumeCreatingLockReturnsOnCall map[int]struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}
	AcquireContainerCreatingLockStub        func(lager.Logger, int) (lock.Lock, bool, error)
	acquireContainerCreatingLockMutex       sync.RWMutex
	acquireContainerCreatingLockArgsForCall []struct {
		arg1 lager.Logger
		arg2 int
	}
	acquireContainerCreatingLockReturns struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}
	acquireContainerCreatingLockReturnsOnCall map[int]struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeGardenWorkerDB) GetPipelineByID(pipelineID int) (db.SavedPipeline, error) {
	fake.getPipelineByIDMutex.Lock()
	ret, specificReturn := fake.getPipelineByIDReturnsOnCall[len(fake.getPipelineByIDArgsForCall)]
	fake.getPipelineByIDArgsForCall = append(fake.getPipelineByIDArgsForCall, struct {
		pipelineID int
	}{pipelineID})
	fake.recordInvocation("GetPipelineByID", []interface{}{pipelineID})
	fake.getPipelineByIDMutex.Unlock()
	if fake.GetPipelineByIDStub != nil {
		return fake.GetPipelineByIDStub(pipelineID)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getPipelineByIDReturns.result1, fake.getPipelineByIDReturns.result2
}

func (fake *FakeGardenWorkerDB) GetPipelineByIDCallCount() int {
	fake.getPipelineByIDMutex.RLock()
	defer fake.getPipelineByIDMutex.RUnlock()
	return len(fake.getPipelineByIDArgsForCall)
}

func (fake *FakeGardenWorkerDB) GetPipelineByIDArgsForCall(i int) int {
	fake.getPipelineByIDMutex.RLock()
	defer fake.getPipelineByIDMutex.RUnlock()
	return fake.getPipelineByIDArgsForCall[i].pipelineID
}

func (fake *FakeGardenWorkerDB) GetPipelineByIDReturns(result1 db.SavedPipeline, result2 error) {
	fake.GetPipelineByIDStub = nil
	fake.getPipelineByIDReturns = struct {
		result1 db.SavedPipeline
		result2 error
	}{result1, result2}
}

func (fake *FakeGardenWorkerDB) GetPipelineByIDReturnsOnCall(i int, result1 db.SavedPipeline, result2 error) {
	fake.GetPipelineByIDStub = nil
	if fake.getPipelineByIDReturnsOnCall == nil {
		fake.getPipelineByIDReturnsOnCall = make(map[int]struct {
			result1 db.SavedPipeline
			result2 error
		})
	}
	fake.getPipelineByIDReturnsOnCall[i] = struct {
		result1 db.SavedPipeline
		result2 error
	}{result1, result2}
}

func (fake *FakeGardenWorkerDB) AcquireVolumeCreatingLock(arg1 lager.Logger, arg2 int) (lock.Lock, bool, error) {
	fake.acquireVolumeCreatingLockMutex.Lock()
	ret, specificReturn := fake.acquireVolumeCreatingLockReturnsOnCall[len(fake.acquireVolumeCreatingLockArgsForCall)]
	fake.acquireVolumeCreatingLockArgsForCall = append(fake.acquireVolumeCreatingLockArgsForCall, struct {
		arg1 lager.Logger
		arg2 int
	}{arg1, arg2})
	fake.recordInvocation("AcquireVolumeCreatingLock", []interface{}{arg1, arg2})
	fake.acquireVolumeCreatingLockMutex.Unlock()
	if fake.AcquireVolumeCreatingLockStub != nil {
		return fake.AcquireVolumeCreatingLockStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.acquireVolumeCreatingLockReturns.result1, fake.acquireVolumeCreatingLockReturns.result2, fake.acquireVolumeCreatingLockReturns.result3
}

func (fake *FakeGardenWorkerDB) AcquireVolumeCreatingLockCallCount() int {
	fake.acquireVolumeCreatingLockMutex.RLock()
	defer fake.acquireVolumeCreatingLockMutex.RUnlock()
	return len(fake.acquireVolumeCreatingLockArgsForCall)
}

func (fake *FakeGardenWorkerDB) AcquireVolumeCreatingLockArgsForCall(i int) (lager.Logger, int) {
	fake.acquireVolumeCreatingLockMutex.RLock()
	defer fake.acquireVolumeCreatingLockMutex.RUnlock()
	return fake.acquireVolumeCreatingLockArgsForCall[i].arg1, fake.acquireVolumeCreatingLockArgsForCall[i].arg2
}

func (fake *FakeGardenWorkerDB) AcquireVolumeCreatingLockReturns(result1 lock.Lock, result2 bool, result3 error) {
	fake.AcquireVolumeCreatingLockStub = nil
	fake.acquireVolumeCreatingLockReturns = struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeGardenWorkerDB) AcquireVolumeCreatingLockReturnsOnCall(i int, result1 lock.Lock, result2 bool, result3 error) {
	fake.AcquireVolumeCreatingLockStub = nil
	if fake.acquireVolumeCreatingLockReturnsOnCall == nil {
		fake.acquireVolumeCreatingLockReturnsOnCall = make(map[int]struct {
			result1 lock.Lock
			result2 bool
			result3 error
		})
	}
	fake.acquireVolumeCreatingLockReturnsOnCall[i] = struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeGardenWorkerDB) AcquireContainerCreatingLock(arg1 lager.Logger, arg2 int) (lock.Lock, bool, error) {
	fake.acquireContainerCreatingLockMutex.Lock()
	ret, specificReturn := fake.acquireContainerCreatingLockReturnsOnCall[len(fake.acquireContainerCreatingLockArgsForCall)]
	fake.acquireContainerCreatingLockArgsForCall = append(fake.acquireContainerCreatingLockArgsForCall, struct {
		arg1 lager.Logger
		arg2 int
	}{arg1, arg2})
	fake.recordInvocation("AcquireContainerCreatingLock", []interface{}{arg1, arg2})
	fake.acquireContainerCreatingLockMutex.Unlock()
	if fake.AcquireContainerCreatingLockStub != nil {
		return fake.AcquireContainerCreatingLockStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.acquireContainerCreatingLockReturns.result1, fake.acquireContainerCreatingLockReturns.result2, fake.acquireContainerCreatingLockReturns.result3
}

func (fake *FakeGardenWorkerDB) AcquireContainerCreatingLockCallCount() int {
	fake.acquireContainerCreatingLockMutex.RLock()
	defer fake.acquireContainerCreatingLockMutex.RUnlock()
	return len(fake.acquireContainerCreatingLockArgsForCall)
}

func (fake *FakeGardenWorkerDB) AcquireContainerCreatingLockArgsForCall(i int) (lager.Logger, int) {
	fake.acquireContainerCreatingLockMutex.RLock()
	defer fake.acquireContainerCreatingLockMutex.RUnlock()
	return fake.acquireContainerCreatingLockArgsForCall[i].arg1, fake.acquireContainerCreatingLockArgsForCall[i].arg2
}

func (fake *FakeGardenWorkerDB) AcquireContainerCreatingLockReturns(result1 lock.Lock, result2 bool, result3 error) {
	fake.AcquireContainerCreatingLockStub = nil
	fake.acquireContainerCreatingLockReturns = struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeGardenWorkerDB) AcquireContainerCreatingLockReturnsOnCall(i int, result1 lock.Lock, result2 bool, result3 error) {
	fake.AcquireContainerCreatingLockStub = nil
	if fake.acquireContainerCreatingLockReturnsOnCall == nil {
		fake.acquireContainerCreatingLockReturnsOnCall = make(map[int]struct {
			result1 lock.Lock
			result2 bool
			result3 error
		})
	}
	fake.acquireContainerCreatingLockReturnsOnCall[i] = struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeGardenWorkerDB) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.getPipelineByIDMutex.RLock()
	defer fake.getPipelineByIDMutex.RUnlock()
	fake.acquireVolumeCreatingLockMutex.RLock()
	defer fake.acquireVolumeCreatingLockMutex.RUnlock()
	fake.acquireContainerCreatingLockMutex.RLock()
	defer fake.acquireContainerCreatingLockMutex.RUnlock()
	return fake.invocations
}

func (fake *FakeGardenWorkerDB) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ worker.GardenWorkerDB = new(FakeGardenWorkerDB)
